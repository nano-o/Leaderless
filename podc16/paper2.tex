\input{header}

%\title{Brief Announcement: A Family of Leaderless Generalized-Consensus Algorithms}

%\author{}

%\date{}

\begin{document}

%\maketitle

\input{cover}

\section{Introduction}

Many agreement algorithms inspired by Paxos and MultiPaxos~\cite{lamport2001paxos} rely on the existence of a unique leader replica which enforces an ordering on commands during fault-free periods.
In practice, the unique leader can easily become a performance bottleneck for the system.
Therefore, recently proposed agreement algorithms like Mencius~\cite{MaoJunqueiraMarzullo08MenciusBuildingEfficientReplicatedStateMachine}, EPaxos~\cite{MoraruAndersenKaminsky13ThereIsMoreConsensusEgalitarianParliaments}, or Alvin~\cite{TurcuETAL14BeGeneralDontGiveUpConsistency} strive to increase performance by avoiding the use of a unique leader.
Mencius rotates the leader among the replicas but its structure remains close to MultiPaxos. 
However, EPaxos and Alvin are based on a novel algorithmic idea first introduced in EPaxos.

In this paper, we show that the core algorithmic idea underlying EPaxos can be used to build a family of leaderless algorithms parameterized by (1) a per-command dependency-set computation algorithm, a concept that we define in the paper, and (2) an algorithm ensuring agreement on a mapping from commands to dependency sets. %(2) an algorithm ensuring a per-command agreement on a dependency set and which is oblivious of any ordering between commands. 
An algorithm in the family is obtained by instantiating the two parameters to a concrete agreement algorithm and a concrete dependency-set computation algorithm, which are then used as sub-routines. 
Note that any generalized consensus algorithm can be used to instantiate parameter 2, but that only a weaker problem than generalized consensus needs to be solved because no ordering constraints need to be enforced.

We prove that all the algorithms in the family are safe and live, and we have formalized our ideas in TLA+ and thoroughly model-check our claims with the TLC model-checker.

Our work sheds light on the common structure of algorithms like EPaxos and Alvin and allows to tune the performance of leaderless algorithms for specific scenarios by changing the underlying generalized-consensus and dependency-set algorithm. 
We expect that these two tunable knobs will allow a principled theoretical and empirical evaluation of the trade-offs that can be achieved by this new family of algorithms.

\section{Leaderless Generalized Consensus Algorithms}

We consider a set of processes $P$ subject to crash-stop faults and communicating by message-passing in an asynchronous network. Processes in $P$ must solve the Generalized Consensus problem~\cite{Lamport05GeneralizeConsensus}. Each process receives proposals for commands of the form $\opn{Propose}(c)$, and it produces responses of the form $\opn{Decide}(\sigma)$, where $\sigma$ is a c-struct. A c-struct set is a set, containing the element $\bot$, with an append operator $\bullet$ such that $\sigma \bullet c$ is a c-struct, for any c-struct $\sigma$ and command $c$. 
We also write the $\sigma\bullet\aseq{c_1,\cdots,c_n}$ for the c-struct $\sigma\bullet c_1\bullet\cdots\bullet c_n$. 
C-structs are partially ordered by the relation $\preceq$ defined such that $\sigma_1\preceq\sigma_2$ iff there exists a sequence of commands $cs$ such that $\sigma_2=\sigma_1\bullet cs$.
We say that two commands \textit{commute} when $\sigma\bullet c_1\bullet c_2 =  \sigma\bullet c_2\bullet c_1 $, for every c-struct $\sigma$. Intuitively, a c-struct represents a set of sequences that are all equivalent up to the ordering of commutative commands (see~\cite{Lamport05GeneralizeConsensus} for a complete discussion on c-struct). 
In the rest of the paper the symbol $c$, possibly sub-scripted, ranges over commands, and the symbol $\mathcal{D}$, possibly sub-scripted, ranges over sets of commands.
\todo{Present generalized consensus here?}

We now present our abstract leaderless generalized consensus algorithm.
A process $p$ receiving a command $c$ proceeds in three phases. First, it calls a \textit{dependency-set} sub-algorithm (\Cref{dep-algo}) to determine a set of commands $cs$ that the command $c$ may depend on. Second, the process $p$ proposes the mapping  $c\mapsto cs$ to a \textit{map-agreement} sub-algorithm (\Cref{map-algo}); the map-agreement sub-algorithm may subsequently commit a mapping $c\mapsto cs'$ for $c$, in which case $cs'$ becomes the set of dependencies of $c$, and we say that $c$ is executable when its dependency set is empty or when all its dependencies are executable. 
Finally, when $c$ is executable, the process $p$ may execute $c$ by deciding the c-struct obtained by running the \emph{graph-processing} algorithm described in \Cref{graph-proc}.
Any other process can run the three phases independently of $p$ and eventually execute the command.
However, we show that a leaderless  generalized consensus algorithm is always safe and is live when at least a majority of the processes are correct.

%In the next sections we present our specification of leaderless generalized consensus algorithms, which is parameterized over a \textit{dependency-set} algorithm (\Cref{dep-algo}) and a \textit{map-agreement} algorithm (\Cref{map-algo}). 


\subsection{Computing Dependency-Sets}
\label{dep-algo}

A dependency-set algorithm exposes the input interface $\opn{announce}_p\left( c \right)$, to announce a command $c$, and the output interface $\opn{suggest}_p \left( c,\mathcal{D}\right)$, to suggest a set of dependencies $\mathcal{D}$ for $c$, where $p\in P$ is the process executing the call.  
Moreover, a dependency-set algorithm must ensure that:
\begin{enumerate}[noitemsep,nolistsep]
    \item For any suggestion $\opn{suggest}_p \left( c,\mathcal{D}\right)$, every command in $\{c\}\cup \mathcal{D}$ must have been announced before.
    \item For any two suggestions $\opn{suggest}_p \left( c_1,\mathcal{D}_1\right)$ and $\opn{suggest}_q \left( c_2,\mathcal{D}_2\right)$ (with $p$ possibly equal to $q$),  if $c_1$ and $c_2$ do not commute then either $c_1\in \mathcal{D}_2$ or $c_2 \in \mathcal{D}_1$.
\end{enumerate}

An example of implementation of such an algorithm is depicted by the pseudocode of \Cref{fig:deps-set-algo}. The idea is to let every process broadcast $c$ to all the processes in the system, in order to announce $c$. Then whenever a process $p$ receives $c$, it replies to the sender with the set $\mathcal{D}$ of commands that $p$ has observed so far, and such that $c$ and any command in $\mathcal{D}$ are \textit{non-commutative}. Afterwards, the process announcing $c$ collects the sets $\mathcal{D}$ for $c$ from a quorum of $\mathcal{Q}$ processes, and it locally suggests the union of those sets as final dependency-set for $c$.

The provided implementation satisfies the two properties of a dependency-set algorithm for the following reasons. Since any command in a dependency-set that is suggested by a process must be in the set $cmds_q$ of the commands received by some process $q$, and a process receives a command if and only if there exists some process that previously announced the command, then it follows that any command in any suggested dependency-set has been previously announced. 

\begin{figure*}
\centering
\subfigure[$\texttt{init}_p$ and $\texttt{announce}_p$ implementations.]{
\noindent\fbox{%
	\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

		\begin{algorithmic}[1]
			{\small
			\START[\texttt{init$_p$}]{{\bf upon}}{$()$} \label{alg:init}
			\State $cmds_p\gets\emptyset$ \label{alg:init-cmds}
			\State $\forall c,$ $deps_p[c]\gets \emptyset$ \label{alg:init-deps}
			\State $\forall c,$ $heard_p[c]\gets \emptyset$ \label{alg:init-heard}
			\State $\forall c,$ $suggested_p[c]\gets false$ \label{alg:init-suggested}
			\END
			\Statex
			\START[\texttt{announce$_p$}]{{\bf upon}}{$(c)$} \label{alg:announce}
			\State $cmds_p\gets cmds_p\cup\{c\}$ \label{alg:add-command}
			\State $\forall q\in P$ {\bf send} $\langle \texttt{cmd}$ $|$ $c \rangle$ {\bf to} $q$\label{alg:send-new-cmd}
			\END
			}
		\end{algorithmic}
	\end{varwidth}%
}
\label{fig:deps-set-algo1}
}
\hspace*{0.3in}\subfigure[receive of \texttt{cmd} and \texttt{deps} messages, and suggestion of dependencies for a command on process $p$.]{
\noindent\fbox{%
	\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

		\begin{algorithmic}[1]
			{\small
			\START[$\langle \texttt{cmd}$ $|$ $c \rangle$]{{\bf upon receive}}{ {\bf from} $q$} \label{alg:receive-new-cmd}
			\State $\mathcal{D} \gets \{ d : d \in cmds_p \land d\neq c \land d \asymp c \}$
			\State $cmds_p\gets cmds_p\cup\{c\}$
			\State {\bf send} $\langle \texttt{deps}$ $|$ $c,\mathcal{D} \rangle$ {\bf to} $q$\label{alg:send-deps}
			\END
			\Statex
			\START[$\langle \texttt{deps}$ $|$ $c,\mathcal{D} \rangle$]{{\bf upon receive}}{ {\bf from} $q$} \label{alg:receive-deps}
			\State $deps_p[c]\gets deps_p[c]\cup \mathcal{D}$
			\State $heard_p[c]\gets heard_p[c]\cup \{q\}$
			\END
			\Statex
			\START[]{{\bf upon}}{$\exists c$ $:$ $ | heard_p[c] | \geq \mathcal{Q}$ $\land$ $suggested_p[c]=false$} \label{alg:receive-deps}
			\State $suggested_p[c]\gets true$
			\State {\bf call} $\texttt{suggest}_p(c,deps_p[c])$
			\END
			}
		\end{algorithmic}
	\end{varwidth}%
}
\label{fig:deps-set-algo2}
}
\caption{Example of dependency-set algorithm implementation.}
\label{fig:deps-set-algo}
\end{figure*}

%\todo{Plain english version below. Which is better?}

%A dependency-set computation algorithm allows processes to announce a command $c$ and to learn about a suggested dependency set for a previously announced command.
%Moreover, a dependency-set computation algorithm must ensure that:
%\begin{enumerate}[noitemsep,nolistsep]
  %  \item If the dependency set $d$ has been suggested for $c$, then every command in $\aset{c}\cup d$ must have been announced before.
  %  \item If the dependency set $d_1$ has been suggested for the command $c_1$, the dependency set $d_2$ has been suggested for the command $c_2$, and $c_1$ and $c_2$ do not commute, then either $c_1\in d_2$ or $c_2 \in d_1$.
%\end{enumerate}

\todo{``Suggest'' can also be used to trigger recovery}.

\todo{Write a suggestion on about GC of dependencies. Remove any command c such that a committed command depends on c. Also us the GC of the map-agreement component.}

\subsection{Agreeing on Dependency Sets}
\label{map-algo}

A map-agreement algorithm exposes the input interface $\opn{propose}_p\left( c, \mathcal{D} \right)$, to propose a set of dependencies $\mathcal{D}$ for a command $c$, and the output interface $\opn{decide}_p\left( c, \mathcal{D} \right)$, to decide $\mathcal{D}$ for $c$, where $p\in P$ is the process executing the call.
Moreover, a map-agreement algorithm must ensure that: 
\begin{enumerate}[noitemsep,nolistsep]
    \item If the set of dependencies $\mathcal{D}$ is decided for a command $c$, then $\mathcal{D}$ has been proposed for $c$ at an earlier time.
    \item If $\mathcal{D}_1$ is decided for a command $c$ and $\mathcal{D}_2$ is decided for the same command $c$, then $\mathcal{D}_1$ is equal to $\mathcal{D}_2$.
 \end{enumerate}

\todo{OR MORE FORMALLY}

\begin{enumerate}[noitemsep,nolistsep]
    \item For any decision $\opn{decide}_p\left( c, \mathcal{D} \right)$, then $\mathcal{D}$ has been proposed for $c$ at an earlier time.
    \item For any two decisions $\opn{decide}_p\left( c, \mathcal{D}_1 \right)$, $\opn{decide}_q\left( c, \mathcal{D}_2 \right)$ (with $p$ possibly equal to $q$), then $\mathcal{D}_1$ is equal to $\mathcal{D}_2$.


\end{enumerate}

Note that any SMR algorithm, like MultiPaxos, can be used to implementing map-agreement by uniquely associating commands to MultiPaxos instance numbers.



\todo{Cite Generalized Paxos as an example for bounding the data structures.}

\subsection{Implementing Leaderless Generalized Consensus}

Genearalized consensus~\cite{Lamport05GeneralizeConsensus} is a specification for state-machine replication algorithms. 
A generalized-consensus algorithm exposes the input actions $propose\left( c \right)$, for a command $c$, and $learn\left( \sigma \right)$, for a c-struct $\sigma$.
Moreover, a generalized-consensus algorithm must ensure that TODO.

We now propose an algorithm that uses the dependency-set computation abstraction and the map-agreement abstraction to implement generalized consensus. We therefore obtain a family of generalized consensus algorithms where each member of the family is obtained by using concrete dependency-set and map-agreement algorithms.

\todo{Explain the algorithm with pseudocode?}

Local variables: $m_p$, a map from commands to dependency sets, initially the empty map; $\sigma_p$, a c-struct, initially $\bot$.
\begin{itemize}[noitemsep,nolistsep]
    \item Upon ${\opn{propose}\left( c \right)}^p$: call ${\opn{announce}\left( c \right)}^p$.
    \item Upon ${\opn{suggest}\left( c,d \right)}^p$: call ${\opn{propose}\left( c,d \right)}^p$.
    \item Upon ${\opn{decide}\left( c,d \right)}^p$: insert the mapping $c \rightarrow d$ in the map $m_p$.
    \item Periodically, update $\sigma_p$ to $\opn{c-struct}\left( m_p \right)$, where $\opn{c-struct}\left( m_p \right)$ is defined below.
\end{itemize}

\subsection{Graph Processing}
\label{graph-proc}

The graph processing algorithm must compute $\opn{c-struct}\left( g_p \right)$, as defined below.
Its main property is Lemma 1; Together with Invariants 1 and 2 (TODO, the invariants guaranteed by the dependency-set algorithm and the map-agreement algorithm), Lemma 1 implies that leaderless algorithms safely implement generalized consensus. 

\textbf{Local dependency graph computed by a process.} The local variable $cs_p$ of a process $p$ can be seen as describing a directed graph $g_p$ whose set of vertices $V\left( g_p \right)$ is the domain of $m_p$ and whose edges $E\left( g_p \right)$ are such that there is an edge from $c_1$ to $c_2$ if and only both $c_1$ and $c_2$ are in $V\left( g_p \right)$ and $v_2 \in m_p\left[ v_1 \right]$ (i.e., $v_1$ depends on $v_2$). For example, if $cs_p = \left[ c_1 \mapsto \aset{c_2,c_3}, c_2 \mapsto \aset{c_1} \right]$ then $V\left(
g_p \right) = \aset{c_1,c_2}$ and $E\left( g_p \right) = \aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right)}$.

\textbf{Graph of strongly connected components.} Given a graph $g$, let $\hat{g}$ be the graph whose vertices are the strongly connected components of $g$ (represented as sets of vertices) and where there is an edge from $g_1$ to $g_2$ if and only if there are two vertices $v_1$ and $v_2$ of $g$ such that $v_1 \in V\left( g_1 \right)$, $v_2 \in V\left( g_2 \right)$, and $\left( v_1,v_2 \right)\in E\left( g \right)$. Note that the reflexive and transitive closure of $V\left(  \hat{g} \right)$ is necessarily a partial order. 
For example, if $V\left( g \right)=\aset{c_1,c_2,c_3,c_4}$ and $E\left( g \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right),\left( c_1,c_3 \right)}$ then $V\left(\hat{g}\right) = \aset{\aset{c_1,c_2},\aset{c_3},\aset{c_4}}$ and $E\left( \hat{g} \right)=\aset{\left( \aset{c_1,c_2},\aset{c_3} \right)}$.

\textbf{Orders induced by a graph.} A directed graph $g$ induces a partial order $\preceq_g$ on its vertices defined such that $v_1 \preceq_g v_2$ iff there is a path from $v_1$ to $v_2$ and there is no path from $v_2$ to $v_1$.
Let $\opn{TOs}\left( g \right)$ be the set of total orders $o$ such that $\preceq_g \subseteq o$.
For example, if $V\left( g \right)=\aset{c_1,c_2,c_3,c_4}$ and $E\left( g \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right),\left( c_1,c_3 \right)}$, then $\preceq_g = \aset{\left( c_1,c_3 \right)}$ and $\opn{TOs}\left( g \right)$ is the set of all permutations of $\aseq{c_1,c_2,c_3,c_4}$ in which $c_1$ comes before $c_3$.

\textbf{Linearization function.} Consider a function $f$ mapping sets of commands to sequences of commands such that $f\left[ cs \right]$ is a total order on the set $cs$.

\textbf{Linearizations of a dependency graph.}
When $\hat{o}$ is a total order over the strongly connected components of $g$ such that $\hat{o} \in \opn{TOs}\left( \hat{g} \right)$, we say that a total order $l$ on $V\left( g \right)$ is a \emph{linearization} of $g$ when $\left(v_1,v_2\right) \in l$ iff (1) there exists $vs_1,vs_2\in V\left(\hat{g}\right)$ such that $v_1\in vs_1$, $v_2\in vs_2$, and $\left( vs_1,vs_2 \right)\in \hat{o}$, or (2) there exists $vs_1\in V\left(\hat{g}\right)$ such that
$v_1,v_2\in  vs_1$ and $\left( v_1,v_2 \right)\in f\left[  vs_1 \right]$.
For example, if $V\left( g \right)=\aset{c_1,c_2,c_3,c_4}$ and $E\left( g \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right),\left( c_1,c_3 \right)}$ and $f\left[ \set{c_1,c_2} \right] = \aseq{c_2,c_1}$ then $\aseq{c_2,c_1,c_3,c_4}$ is a linearization of $g$ but $\aseq{c_1,c_2,c_3,c_4}$ is not and neither is $\aseq{c_3,c_2,c_1,c_4}$

\textbf{Partial order on graphs.}
If $g_1$ and $g_2$ are two graphs, then we write $g_1 \leq g_2$ iff $V\left( g_1 \right)\subseteq V\left( g_2 \right)$, and if $v\in V\left( g_1 \right)$, $e\in E\left( g_2 \right)$, and $v$ is an endpoint of $e$, then $e\in E\left( g_1 \right)$. 

\textbf{Lemma 1}:
Assume that: $g_1$ and $g_2$ are two dependency graphs; 
for every pair of non-commutative commands $c_1,c_2 \in V\left(g_2\right)$, either $\left( c_1,c_2 \right)\in E\left( g_2 \right)$ or $\left( c_2,c_1 \right)\in E\left( g_2 \right)$;
$g_1 \leq g_2$;
$l_1$ is a linearization of $g_1$ and $l_2$ is a linearization of $g_2$. 
Then we have (a), $\bot\bullet l_1 \preceq \bot\bullet l_2$, and (b), if $g_1 = g_2$ then $\bot\bullet l_1 = \bot\bullet l_2$.

\textbf{Definition of $\opn{c-struct}\left( m_p \right)$}.
We define $\opn{c-struct}\left( m_p \right) = \bot\bullet l$ where $l$ is a linearization of $g_p$.
By lemma 1.b, $\opn{c-struct}\left( m_p \right)$ is well-defined.

\begin{comment}
Define $\opn{Lin}_g\left( \leq \right) = f\left[ V_1 \right] \cdot F\left[ V_2 \right] \cdot F\left[ V_n \right]$, where $V_i\in V\left( \hat{g} \right)$ 


Define the set of linearizations $\opn{Lins}\left( g \right)$ of a graph $g$ a the set of sequences whose length is the cardinality of $V\left( g \right)$, which contain each element of $V\left( g \right)$ exactly once, and ... \todo{or first define the partial order induced by a graph and then its compatible total orders.}

Consider a function $f$ mapping sets of commands to sequences of commands such that $f\left[ cs \right]$ contains each command in $cs$ exactly once.
A sequence of commands $cseq$ is an $f$-linearization of the graph $g$ if and only there is a sequence whose element of strongly connected 

\todo{Explain the graph processing algo independently? Its key property is that when $G1 \subseteq G2$ then $lin\left( c_1,G1 \right)$ is a prefix of $lin\left( c_2,G2 \right)$ or vice-versa.}

\end{comment}

\subsection{Correctenss Proof}

\subsection{Obtaining EPaxos}

\printbibliography%

\end{document}
