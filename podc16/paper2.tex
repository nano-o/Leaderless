\input{header}

%\title{Brief Announcement: A Family of Leaderless Generalized-Consensus Algorithms}

%\author{}

%\date{}

\begin{document}

%\maketitle

\input{cover}

\section{Introduction}

Many agreement algorithms inspired by Paxos and MultiPaxos~\cite{lamport2001paxos} rely on the existence of a unique leader replica which enforces an ordering on commands during fault-free periods.
In practice, the unique leader can easily become a performance bottleneck for the system.
Therefore, recently proposed agreement algorithms like Mencius~\cite{MaoJunqueiraMarzullo08MenciusBuildingEfficientReplicatedStateMachine}, EPaxos~\cite{MoraruAndersenKaminsky13ThereIsMoreConsensusEgalitarianParliaments}, or Alvin~\cite{TurcuETAL14BeGeneralDontGiveUpConsistency} strive to increase performance by avoiding the use of a unique leader.
Mencius rotates the leader among the replicas but its structure remains close to MultiPaxos. 
However, EPaxos and Alvin are based on a novel algorithmic idea first introduced in EPaxos.

In this paper, we show that the core algorithmic idea underlying EPaxos can be used to build a family of leaderless algorithms parameterized by (1) a per-command dependency-set computation algorithm, a concept that we define in the paper, and (2) an algorithm ensuring agreement on a mapping from commands to dependency sets. %(2) an algorithm ensuring a per-command agreement on a dependency set and which is oblivious of any ordering between commands. 
An algorithm in the family is obtained by instantiating the two parameters to a concrete agreement algorithm and a concrete dependency-set computation algorithm, which are then used as sub-routines. 
Note that any generalized consensus algorithm can be used to instantiate parameter 2, but that only a weaker problem than generalized consensus needs to be solved because no ordering constraints need to be enforced.

We prove that all the algorithms in the family are safe and live, and we have formalized our ideas in TLA+ and thoroughly model-check our claims with the TLC model-checker.

Our work sheds light on the common structure of algorithms like EPaxos and Alvin and allows to tune the performance of leaderless algorithms for specific scenarios by changing the underlying generalized-consensus and dependency-set algorithm. 
We expect that these two tunable knobs will allow a principled theoretical and empirical evaluation of the trade-offs that can be achieved by this new family of algorithms.

\section{Leaderless Generalized Consensus Algorithms}

We consider a set of processes $P$ subject to crash-stop faults and communicating by message-passing in an asynchronous network. Processes in $P$ must solve the Generalized Consensus problem~\cite{Lamport05GeneralizeConsensus}. Each process receives proposals for commands of the form $\opn{Propose}(c)$, and it produces responses of the form $\opn{Decide}(\sigma)$, where $\sigma$ is a c-struct. A c-struct set is a set, containing the element $\bot$, with an append operator $\bullet$ such that $\sigma \bullet c$ is a c-struct, for any c-struct $\sigma$ and command $c$. 
We also write the $\sigma\bullet\aseq{c_1,\cdots,c_n}$ for the c-struct $\sigma\bullet c_1\bullet\cdots\bullet c_n$. 
C-structs are partially ordered by the relation $\preceq$ defined such that $\sigma_1\preceq\sigma_2$ iff there exists a sequence of commands $cs$ such that $\sigma_2=\sigma_1\bullet cs$.
We say that two commands \textit{commute} when $\sigma\bullet c_1\bullet c_2 =  \sigma\bullet c_2\bullet c_1 $, for every c-struct $\sigma$. Intuitively, a c-struct represents a set of sequences that are all equivalent up to the ordering of commutative commands (see~\cite{Lamport05GeneralizeConsensus} for a complete discussion on c-struct). 
In the rest of the paper the symbol $c$, possibly sub-scripted, ranges over commands, and the symbol $\mathcal{D}$, possibly sub-scripted, ranges over sets of commands.
\todo{Present generalized consensus here?}

We now present our abstract leaderless generalized consensus algorithm.
A process $p$ receiving a command $c$ proceeds in three phases. First, it calls a \textit{dependency-set} sub-algorithm (\Cref{dep-algo}) to determine a set of commands $cs$ that the command $c$ may depend on. Second, the process $p$ proposes the mapping  $c\mapsto cs$ to a \textit{map-agreement} sub-algorithm (\Cref{map-algo}); the map-agreement sub-algorithm may subsequently commit a mapping $c\mapsto cs'$ for $c$, in which case $cs'$ becomes the set of dependencies of $c$, and we say that $c$ is executable when its dependency set is empty or when all its dependencies are executable. 
Finally, when $c$ is executable, the process $p$ may execute $c$ by deciding the c-struct obtained by running the \emph{graph-processing} algorithm described in \Cref{graph-proc}.
Any other process can run the three phases independently of $p$ and eventually execute the command.
However, we show that a leaderless  generalized consensus algorithm is always safe and is live when at least a majority of the processes are correct.

%In the next sections we present our specification of leaderless generalized consensus algorithms, which is parameterized over a \textit{dependency-set} algorithm (\Cref{dep-algo}) and a \textit{map-agreement} algorithm (\Cref{map-algo}). 


\subsection{Computing Dependency-Sets}
\label{dep-algo}

A dependency-set algorithm exposes the input interface $\opn{announce}_p\left( c \right)$, to announce a command $c$, and the output interface $\opn{suggest}_p \left( c,\mathcal{D}\right)$, to suggest a set of dependencies $\mathcal{D}$ for $c$, where $p\in P$ is the process executing the call.  
Moreover, a dependency-set algorithm must ensure that:
\begin{enumerate}[noitemsep,nolistsep]
    \item For any suggestion $\opn{suggest}_p \left( c,\mathcal{D}\right)$, every command in $\{c\}\cup \mathcal{D}$ must have been announced before.
    \item For any two suggestions $\opn{suggest}_p \left( c_1,\mathcal{D}_1\right)$ and $\opn{suggest}_q \left( c_2,\mathcal{D}_2\right)$ (with $p$ possibly equal to $q$),  if $c_1$ and $c_2$ do not commute then either $c_1\in \mathcal{D}_2$ or $c_2 \in \mathcal{D}_1$.
\end{enumerate}

%\todo{Plain english version below. Which is better?}

%A dependency-set computation algorithm allows processes to announce a command $c$ and to learn about a suggested dependency set for a previously announced command.
%Moreover, a dependency-set computation algorithm must ensure that:
%\begin{enumerate}[noitemsep,nolistsep]
  %  \item If the dependency set $d$ has been suggested for $c$, then every command in $\aset{c}\cup d$ must have been announced before.
  %  \item If the dependency set $d_1$ has been suggested for the command $c_1$, the dependency set $d_2$ has been suggested for the command $c_2$, and $c_1$ and $c_2$ do not commute, then either $c_1\in d_2$ or $c_2 \in d_1$.
%\end{enumerate}

\todo{``Suggest'' can also be used to trigger recovery}.

\subsection{Agreeing on Dependency Sets}
\label{map-algo}

A map-agreement algorithm exposes the input interface $\opn{propose}_p\left( c, \mathcal{D} \right)$, to propose a set of dependencies $\mathcal{D}$ for a command $c$, and the output interface $\opn{decide}_p\left( c, \mathcal{D} \right)$, to decide $\mathcal{D}$ for $c$, where $p\in P$ is the process executing the call.
Moreover, a map-agreement algorithm must ensure that: 
\begin{enumerate}[noitemsep,nolistsep]
    \item If the set of dependencies $\mathcal{D}$ is decided for a command $c$, then $\mathcal{D}$ has been proposed for $c$ at an earlier time.
    \item If $\mathcal{D}_1$ is decided for a command $c$ and $\mathcal{D}_2$ is decided for the same command $c$, then $\mathcal{D}_1$ is equal to $\mathcal{D}_2$.
 \end{enumerate}

\todo{OR MORE FORMALLY}

\begin{enumerate}[noitemsep,nolistsep]
    \item For any decision $\opn{decide}_p\left( c, \mathcal{D} \right)$, then $\mathcal{D}$ has been proposed for $c$ at an earlier time.
    \item For any two decisions $\opn{decide}_p\left( c, \mathcal{D}_1 \right)$, $\opn{decide}_q\left( c, \mathcal{D}_2 \right)$ (with $p$ possibly equal to $q$), then $\mathcal{D}_1$ is equal to $\mathcal{D}_2$.


\end{enumerate}

Note that any SMR algorithm, like MultiPaxos, can be used to implementing map-agreement by uniquely associating commands to MultiPaxos instance numbers.

\subsection{Implementing Leaderless Generalized Consensus}

Genearalized consensus~\cite{Lamport05GeneralizeConsensus} is a specification for state-machine replication algorithms. 
A generalized-consensus algorithm exposes the input actions $propose\left( c \right)$, for a command $c$, and $learn\left( \sigma \right)$, for a c-struct $\sigma$.
Moreover, a generalized-consensus algorithm must ensure that TODO.

We now propose an algorithm that uses the dependency-set computation abstraction and the map-agreement abstraction to implement generalized consensus. We therefore obtain a family of generalized consensus algorithms where each member of the family is obtained by using concrete dependency-set and map-agreement algorithms.

\todo{Explain the algorithm with pseudocode?}

Local variables: $\opn{cs}_p$, a map from commands to dependency sets, initially the empty map.
\begin{itemize}[noitemsep,nolistsep]
    \item Upon ${\opn{propose}\left( c \right)}^p$: call ${\opn{announce}\left( c \right)}^p$.
    \item Upon ${\opn{suggest}\left( c,d \right)}^p$: call ${\opn{propose}\left( c,d \right)}^p$.
    \item Upon ${\opn{decide}\left( c,d \right)}^p$: insert the mapping $c \rightarrow d$ in the map $\opn{cs}_p$.
    \item Periodically,  every process $p$ processes $\opn{cs}_p$, as described below.
\end{itemize}

\subsection{Graph Processing}
\label{graph-proc}

The local variable $cs_p$ of a process $p$ can be seen as describing a directed graph $g_p$ whose set of vertices $V\left( g_p \right)$ is the domain of $\opn{cs}_p$ and whose edges $E\left( g_p \right)$ are such that there is an edge from $c_1$ to $c_2$ if and only both $c_1$ and $c_2$ are in $V\left( g_p \right)$ and $v_2 \in \opn{cs}_p\left[ v_1 \right]$ (i.e., $v_1$ depends on $v_2$). For example, if $cs_p = \left[ c_1 \mapsto \aset{c_2,c_3}, c_2 \mapsto \aset{c_1} \right]$ then $V\left(
g_p \right) = \aset{c_1,c_2}$ and $E\left( g_p \right) = \aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right)}$.

Given a graph $g$, let $\hat{g}$ be the graph whose vertices are the strongly connected components of $g$ and where there is an edge from $g_1$ to $g_2$ if and only if there are two vertices $v_1$ and $v_2$ of $g$ such that $v_1 \in V\left( g_1 \right)$, $v_2 \in V\left( g_2 \right)$, and $\left( v_1,v_2 \right)\in E\left( g \right)$. Note that the reflexive and transitive closure of $V\left(  \hat{g} \right)$ is necessarily a partial order. For example, if $V\left( g
\right)=\aset{c_1,c_2,c_3,c_4}$
and $E\left( g \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right),\left( c_1,c_3 \right)}$ then $V\left(\hat{g}\right) = \aset{\aset{c_1,c_2},\aset{c_3},\aset{c_4}}$ and $E\left( \hat{g} \right)=\aset{\left( \aset{c_1,c_2},\aset{c_3} \right)}$.

A directed graph $g$ induces a partial order $\preceq_g$ on its vertices defined such that $v_1 \preceq_g v_2$ iff there is a path from $v_1$ to $v_2$ and there is no path from $v_2$ to $v_1$.
Let $\opn{TOs}\left( g \right)$ be the set of total orders $\leq$ such that $\preceq_g \subseteq \leq$

Consider a function $f$ mapping sets of commands to sequences of commands such that $f\left[ cs \right]$ is a total order on the set $cs$.

When $\hat{o}$ is a total order in $\opn{TOs}\left( \hat{g} \right)$, define the total order $\leq_{\hat{o}}^g$ on $V\left( g \right)$ such that $v_1 \leq_{\hat{o}}^g v_2$ iff (1) there exists $V_1,V_2\in V\left(\hat{g}\right)$ such that $v_1\in V_1$, $v_2\in V_2$, and $\left( V_1,V_2 \right)\in \hat{o}$, or (2) there exists $V\in V\left(\hat{g}\right)$ such that $v_1,v_2\in V\left( V \right)$ and $\left( v_1,v_2 \right)\in f\left[ V\left( V \right) \right]$.
We say that $\leq_{\hat{o}}^g$ is a \emph{linearization} of $g$.

Property: if $V\left( g_1 \right)\subseteq V\left( g_2 \right)$, $E\left( g_1 \right)\subseteq E\left( g_2 \right)$, $l_1$ is a linearization of $g_1$ and $l_2$ is a linearization of $g_2$, then $\bot\bullet l1 \preceq \bot\bullet l2$.

\begin{comment}
Define $\opn{Lin}_g\left( \leq \right) = f\left[ V_1 \right] \cdot F\left[ V_2 \right] \cdot F\left[ V_n \right]$, where $V_i\in V\left( \hat{g} \right)$ 


Define the set of linearizations $\opn{Lins}\left( g \right)$ of a graph $g$ a the set of sequences whose length is the cardinality of $V\left( g \right)$, which contain each element of $V\left( g \right)$ exactly once, and ... \todo{or first define the partial order induced by a graph and then its compatible total orders.}

Consider a function $f$ mapping sets of commands to sequences of commands such that $f\left[ cs \right]$ contains each command in $cs$ exactly once.
A sequence of commands $cseq$ is an $f$-linearization of the graph $g$ if and only there is a sequence whose element of strongly connected 

\todo{Explain the graph processing algo independently? Its key property is that when $G1 \subseteq G2$ then $lin\left( c_1,G1 \right)$ is a prefix of $lin\left( c_2,G2 \right)$ or vice-versa.}

\end{comment}

\subsection{Correctenss Proof}

\subsection{Obtaining EPaxos}

\printbibliography%

\end{document}
