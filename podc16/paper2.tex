\input{header}

\title{Brief Announcement: A Family of Leaderless Generalized-Consensus Algorithms}

\author{}

\date{}

\begin{document}

\maketitle

\section{Introduction}

Many agreement algorithms inspired by Paxos and MultiPaxos~\cite{lamport2001paxos} rely on the existence of a unique leader replica which enforces an ordering on commands during fault-free periods.
In practice, the unique leader can easily become a performance bottleneck for the system.
Therefore, recently proposed agreement algorithms like Mencius~\cite{MaoJunqueiraMarzullo08MenciusBuildingEfficientReplicatedStateMachine}, EPaxos~\cite{MoraruAndersenKaminsky13ThereIsMoreConsensusEgalitarianParliaments}, or Alvin~\cite{TurcuETAL14BeGeneralDontGiveUpConsistency} strive to increase performance by avoiding the use of a unique leader.
Mencius rotates the leader among the replicas but its structure remains close to MultiPaxos. 
However, EPaxos and Alvin are based on a novel algorithmic idea first introduced in EPaxos.

In this paper, we show that the core algorithmic idea underlying EPaxos can be used to build a family of leaderless algorithms parameterized by (1) a per-command dependency-set computation algorithm, a concept that we define in the paper, and (2) an algorithm ensuring agreement on a mapping from commands to dependency sets. %(2) an algorithm ensuring a per-command agreement on a dependency set and which is oblivious of any ordering between commands. 
An algorithm in the family is obtained by instantiating the two parameters to a concrete agreement algorithm and a concrete dependency-set computation algorithm, which are then used as sub-routines. 
Note that any generalized consensus algorithm can be used to instantiate parameter 2, but that only a weaker problem than generalized consensus needs to be solved because no ordering constraints need to be enforced.

We prove that all the algorithms in the family are safe and live, and we have formalized our ideas in TLA+ and thoroughly model-check our claims with the TLC model-checker.

Our work sheds light on the common structure of algorithms like EPaxos and Alvin and allows to tune the performance of leaderless algorithms for specific scenarios by changing the underlying generalized-consensus and dependency-set algorithm. 
We expect that these two tunable knobs will allow a principled theoretical and empirical evaluation of the trade-offs that can be achieved by this new family of algorithms.

\section{Leaderless Algorithms}

%\todo{Let's base everything on C-Structs; it will be easier. We can say that two commands commute when $\sigma\bullet c_1\bullet c_2 =  \sigma\bullet c_2\bullet c_1 $ for every cstruct $\sigma$.} 


We consider a set of processes $P$ subject to crash-stop faults and communicating by message-passing in an asynchronous network. Processes in $P$ must solve the Generalized Consensus problem~\cite{lamport-generalized}. Each process receives proposals for commands of the form \texttt{Propose}$(c)$, and it produces responses of the form \texttt{Decide}$(\sigma)$, where $\sigma$ is a c-struct. A c-struct set is a set, containing the element $\bot$, with an append operator $\bullet$ such that $\sigma \bullet c$ is a c-struct, for any c-struct $\sigma$ and command $c$. We say that two commands \textit{commute} when $\sigma\bullet c_1\bullet c_2 =  \sigma\bullet c_2\bullet c_1 $, for every c-struct $\sigma$. Intuitively, a c-struct represents a set of sequences that are all equivalent up to the ordering of commutative commands (see~\cite{lamport-generalized} for a complete discussion on c-struct). In the rest of the paper, unless otherwise specified, the symbol $c$, possibly sub-scripted, ranges over commands, and the symbol $\mathcal{D}$, possibly sub-scripted, ranges over sets of commands.

In the next sections we present our specification of leaderless generalized consensus algorithms, which is parameterized over a \textit{dependency-set} algorithm (\Cref{dep-algo}) and a \textit{map-agreement} algorithm (\Cref{map-algo}). 
%Processes proposals of commands to the \textit{Generalized Consensus} layer
%We also consider a deterministic state-machine $M$ whose set of commands is $C$. 
%We say that two commands $c_a$, $c_b$ \textit{commute} if executing $c_a$ before $c_b$ has the same effect on the state machine as executing $c_b$ before $c_a$. We assume that a command does not commute with itself.
%We also consider a symmetric relation $R \subseteq C\times C$, called \textit{dependency relation}, such that: for any command $c$, $\left( c,c \right)\notin R$, and if $\left( c_a,c_b \right)\notin R$ then $c_a$ and $c_b$ commute. 

\subsection{Computing Dependency-Sets}
\label{dep-algo}

A dependency-set algorithm exposes the input interface $\texttt{announce}_p\left( c \right)$, where $c$ is a command, and the output interface $\texttt{suggest}_p \left( c,\mathcal{D}\right)$, where $p\in P$ is the process executing the call.  
Moreover, a dependency-set algorithm must ensure that:
\begin{enumerate}[noitemsep,nolistsep]
    \item For any suggestion $\texttt{suggest}_p \left( c,\mathcal{D}\right)$, every command in $\{c\}\cup \mathcal{D}$ must have been announced before.
    \item For any two suggestions $\texttt{suggest}_p \left( c_1,\mathcal{D}_1\right)$ and $\texttt{suggest}_q \left( c_2,\mathcal{D}_2\right)$ (with $p$ possibly equal to $q$),  if $c_1$ and $c_2$ do not commute then either $c_1\in d_2$ or $c_2 \in d_1$.
\end{enumerate}

%\todo{Plain english version below. Which is better?}

%A dependency-set computation algorithm allows processes to announce a command $c$ and to learn about a suggested dependency set for a previously announced command.
%Moreover, a dependency-set computation algorithm must ensure that:
%\begin{enumerate}[noitemsep,nolistsep]
  %  \item If the dependency set $d$ has been suggested for $c$, then every command in $\aset{c}\cup d$ must have been announced before.
  %  \item If the dependency set $d_1$ has been suggested for the command $c_1$, the dependency set $d_2$ has been suggested for the command $c_2$, and $c_1$ and $c_2$ do not commute, then either $c_1\in d_2$ or $c_2 \in d_1$.
%\end{enumerate}

\todo{``Suggest'' can also be used to trigger recovery}.

\subsection{Agreeing on Dependency Sets}
\label{map-algo}

A map-agreement algorithm exposes the input actions ${propose\left( c, d \right)}^p$ and the output actions ${decide\left( c, d \right)}^p$, for a command $c$, a set of commands $d$, and a process $p$.
Moreover, a map-agreement algorithm must ensure that: 
\begin{enumerate}[noitemsep,nolistsep]
    \item If the set of dependencies $d$ is decided for a command $c$, then $d$ has been proposed for $c$ at an earlier time.
    \item If $d_1$ is decided for a command $c$ and $d_2$ is decided for the same command $c$, then $d_1$ is equal to $d_2$.
\end{enumerate}
Note that any SMR algorithm, like MultiPaxos, can be used to implementing map-agreement by uniquely associating commands to MultiPaxos instance numbers.

\subsection{Implementing Leaderless Generalized Consensus}

Genearalized consensus~\cite{Lamport05GeneralizeConsensus} is a specification for state-machine replication algorithms. 
A generalized-consensus algorithm exposes the input actions $propose\left( c \right)$, for a command $c$, and $learn\left( \sigma \right)$, for a c-struct $\sigma$.
Moreover, a generalized-consensus algorithm must ensure that TODO.

We now propose an algorithm that uses the dependency-set computation abstraction and the map-agreement abstraction to implement generalized consensus. We therefore obtain a family of generalized consensus algorithms where each member of the family is obtained by using concrete dependency-set and map-agreement algorithms.

\todo{Explain the algorithm with pseudocode?}
Local variables: committed, a map from commands to dependency sets, initially the empty map.
\begin{itemize}[noitemsep,nolistsep]
    \item Upon ${propose\left( c \right)}^p$: call ${announce\left( c \right)}^p$.
    \item Upon ${suggest\left( c,d \right)}^p$: call ${propose\left( c,d \right)}^p$.
    \item Upon ${decide\left( c,d \right)}^p$: insert the mapping $c \rightarrow d$ in the map ``committed''.
    \item Periodically: process the committed commands, as described below.
\end{itemize}

The variable ``committed'' of the algorithm above can be seen as describing a directed graph $g$ whose vertices are commands and such that there is an edge from $c_1$ to $c_2$ if and only if ``committed'' maps $v_1$ to a set $deps$ where $v_2\in deps$, i.e. $v_1$ depends on $v_2$.


\todo{Explain the graph processing algo independently? Its key property is that when $G1 \subseteq G2$ then $lin\left( c_1,G1 \right)$ is a prefix of $lin\left( c_2,G2 \right)$ or vice-versa.}

\printbibliography%

\end{document}
