\input{header}

\title{\vspace{-0.8in}Brief Announcement: A Family of Leaderless Generalized-Consensus Algorithms}

\author{
Author 1\\
ECE, Virginia Tech\\
email
\and
Author 2\\
ECE, Virginia Tech\\
email
\and
Author 3\\
ECE, Virginia Tech\\
email
}

\date{}

\begin{document}

\maketitle

%\input{cover}

\section{Introduction}

Many agreement algorithms inspired by Paxos and MultiPaxos~\cite{lamport2001paxos} rely on the existence of a unique leader process which enforces an ordering on commands during fault-free periods.
In practice, the unique leader can easily become a performance bottleneck for the system.
Therefore, recently proposed agreement algorithms like Mencius~\cite{MaoJunqueiraMarzullo08MenciusBuildingEfficientReplicatedStateMachine}, EPaxos~\cite{MoraruAndersenKaminsky13ThereIsMoreConsensusEgalitarianParliaments}, or Alvin~\cite{TurcuETAL14BeGeneralDontGiveUpConsistency} strive to increase performance by avoiding the use of a unique leader.
Mencius rotates the leader among the processes but its structure remains close to MultiPaxos. 
However, EPaxos and Alvin are based on a novel algorithmic idea first introduced in EPaxos.

We show that the core idea underlying EPaxos can be captured in a generic algorithm that uses two abstractions: (1), a per-command dependency-set computation algorithm, a concept that we define in the paper, and (2), an algorithm ensuring, for each command proposed to it, agreement on a dependency set. Both abstractions lend themselves well to implementations that avoid the use of a unique leader process.

Our abstract algorithm gives rise to a family of algorithms whose members are obtained by using a concrete map-agreement algorithm and a concrete dependency-set computation algorithm. 
Note that any generalized consensus algorithm can be used to implement (2), but only a weaker problem than generalized consensus needs to be solved because no ordering among proposal is required.

Our work has two main advantages: it enables modular correctness proofs of algorithms like EPaxos and it allows to tune the performance of implementations by changing the underlying map-agreement and dependency-set algorithms. We expect that these two tunable knobs will allow a principled theoretical and empirical evaluation of the trade-offs that can be achieved by this new family of algorithms.

We prove that all the algorithms in the family are safe and live, and we have formalized our ideas in TLA+ and have thoroughly model-checked our safety claims with the TLC model-checker.

\section{Leaderless Generalized Consensus Algorithms}

We consider a set of processes $P$ subject to crash-stop faults and communicating by message-passing in an asynchronous network. Processes in $P$ must solve the Generalized Consensus problem~\cite{Lamport05GeneralizeConsensus}. Each process receives proposals for commands of the form $\opn{Propose}(c)$, and must produce responses of the form $\opn{Decide}(\sigma)$, where $\sigma$ is a c-struct. 
The sequence of calls observed must satisfy the non-triviality, consistency, stability, and liveness properties described below.
We refer the reader to~\cite{Lamport05GeneralizeConsensus}, and we use the same notation, for the definition of c-structs and generalized consensus. Briefly, the c-structs are a set of elements, including $\bot$, with an operator $\bullet$ for appending commands to a c-struct. C-structs are partially ordered: $\sigma_1\sqsubseteq \sigma_2$ iff there exists a sequence of commands $\mathcal{D}$ such that $\sigma_2 = \sigma_1\bullet \mathcal{D}$ and $\bot\sqsubseteq \sigma$ for any
$\sigma$. Two c-structs are compatible when they have a
common upper bound. Intuitively, a c-struct represents a set of sequences that are all equivalent up to the ordering of commutative commands. The consistency property of generalized consensus requires that any two decided c-structs be compatible.

We now present our abstract leaderless generalized consensus algorithm.
A process $p$ receiving a command $c$ proceeds in three phases. First, it calls a \textit{dependency-set} sub-algorithm (\Cref{dep-algo}) to determine a set of commands $\mathcal{D}$ that the command $c$ may depend on. Second, $p$ proposes the mapping  $c\mapsto \mathcal{D}$ to a \textit{map-agreement} sub-algorithm (\Cref{map-algo}); the map-agreement sub-algorithm may subsequently commit a mapping $c\mapsto \mathcal{D}'$ for $c$, in which case $\mathcal{D}'$ becomes the dependency set of $c$;
we say that $c$ is executable when all its transitive dependencies are known. %no command $c'$ for which no mapping has been committed is reachable from $c$ by recursively following committed mappings. 
\todo{Change the name of the the decide action to commit.}
Finally, when $c$ is executable, the $p$ may execute $c$ by deciding the c-struct obtained by \emph{locally} running a \emph{graph-processing} algorithm described in \Cref{abstract-algo}.
Any other process can run the three phases independently of $p$ and eventually execute the command despite a crash of $p$.
However, we show that a leaderless  generalized consensus algorithm is always safe and is live when its underlying dependency-set and map-agreement algorithms are safe and live.
The leaderless generalized consensus algorithm orchestrates the two dependency-set and map-agreement sub-algorithms as shown in \cref{fig:deps-set-algo3}.\todo{This pseudocode must be in figure (a). Also we have to better describe the pseudocode.}

%In the next sections we present our specification of leaderless generalized consensus algorithms, which is parameterized over a \textit{dependency-set} algorithm (\Cref{dep-algo}) and a \textit{map-agreement} algorithm (\Cref{map-algo}). 


\subsection{Computing Dependency-Sets}
\label{dep-algo}

A dependency-set algorithm exposes the input interface $\opn{announce}_p\left( c \right)$, to announce a command $c$, the output interface $\opn{suggest}_p \left( c,\mathcal{D}\right)$, to suggest a set of dependencies $\mathcal{D}$ for $c$, and \todo{this is not clear: an input interface $\opn{commit}\left( c,\mathcal{D} \right)$ (meant to receive inputs from the agreement sub-algorithm)}, where $p\in P$ is the process executing the call.
Moreover, a dependency-set algorithm must ensure that:
\begin{enumerate}[noitemsep,nolistsep]
    \item For any suggestion $\opn{suggest}_p \left( c,\mathcal{D}\right)$, every command in $\{c\}\cup \mathcal{D}$ must have been announced before.
    \item For any two suggestions $\opn{suggest}_p \left( c_1,\mathcal{D}_1\right)$ and $\opn{suggest}_q \left( c_2,\mathcal{D}_2\right)$ (with $p$ possibly equal to $q$), if $c_1$ and $c_2$ do not commute then either $c_1\in \mathcal{D}_2$ or $c_2 \in \mathcal{D}_1$.
    \item If a suggestion $\opn{suggest}_p(c,\mathcal{D})$ has been made and no input $\opn{commit}_q\left( c,\mathcal{D'} \right)$ is observed, then eventually a new suggestion $\opn{suggest}_r\left( c,\mathcal{D''} \right)$ for $r\neq p$ is made.
\end{enumerate}

An example of implementation of such an algorithm is depicted by the pseudocode of Figures~\ref{fig:deps-set-algo1} and~\ref{fig:deps-set-algo2}. The idea is to let every process broadcast $c$ to all the processes in the system, in order to announce $c$ (lines \ref{alg:announce}--\ref{alg:send-new-cmd}). Then whenever a process $p$ receives $c$, it replies to the sender with the set $\mathcal{D}$ of commands that $p$ has observed so far, and such that $c$ and any command in $\mathcal{D}$ do not commute (lines \ref{alg:receive-new-cmd}--\ref{alg:send-deps}). Afterwards, the process announcing $c$ collects the sets $\mathcal{D}$ for $c$ from a \textit{quorum} of $\mathcal{Q}$ processes, and it locally suggests the union of those sets as final dependency-set for $c$ (lines \ref{alg:receive-deps}--\ref{alg:call-suggest}). For the purpose of this example we allow for $\mathcal{Q}$ to be equal to any positive integer that is not greater than the number of processes, as long as the following requirement is met: the intersection of any two quorums that are selected by processes to collect the sets of dependencies is not empty.

The provided implementation satisfies the specification of a dependency-set algorithm for the following reasons. Since any command in a dependency-set that is suggested by a process (lines~\ref{alg:update-deps-p} and~\ref{alg:call-suggest}) must be in the set $cmds_q$ of the commands received by some process $q$ (line~\ref{alg:update-d}), and a process receives a command if and only if there exists some process that previously announced the command (line~\ref{alg:send-new-cmd}), then it follows that any command in any suggested dependency-set has been previously announced. Further, since a process can suggest a set of dependencies $deps_p[c]$ for a command $c$ after it has received a reply for $c$ from at least a quorum of processes (lines~\ref{alg:receive-deps}--\ref{alg:call-suggest}), we have that $\opn{suggest}_p \left( c,deps_p[c]\right)$ is called only if a quorum of processes $q$ have $c$ in their $cmds_q$ (line~\ref{alg:update-cmds-p}). Therefore, by the requirement that we enforced on the quorums, we can conclude that for any two suggestions $\opn{suggest}_p \left( c_1,deps_p[c_1]\right)$ and $\opn{suggest}_q \left( c_2,deps_q[c_2]\right)$,  if $c_1$ and $c_2$ do not commute then either $c_1\in deps_q[c_2]$ or $c_2 \in deps_p[c_1]$.

\begin{figure*}
\centering
\subfigure[$\texttt{init}_p$ and $\texttt{announce}_p$ implementations.]{
\noindent\fbox{%
	\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

		\begin{algorithmic}[1]
			{\scriptsize
			\START[\texttt{init$_p$}]{{\bf upon}}{$()$} \label{alg:init}
			\State $cmds_p\gets\emptyset$ \label{alg:init-cmds}
			\State $\forall c,$ $deps_p[c]\gets \emptyset$ \label{alg:init-deps}
			\State $\forall c,$ $heard_p[c]\gets \emptyset$ \label{alg:init-heard}
			\State $\forall c,$ $suggested_p[c]\gets false$ \label{alg:init-suggested}
			\END
			\Statex
			\START[\texttt{announce$_p$}]{{\bf upon}}{$(c)$} \label{alg:announce}
			\State $cmds_p\gets cmds_p\cup\{c\}$ \label{alg:add-command}
			\State $\forall q\in P$ {\bf send} $\langle \texttt{cmd}$ $|$ $c \rangle$ {\bf to} $q$\label{alg:send-new-cmd}
			\END
			}
		\end{algorithmic}
	\end{varwidth}%
}
\label{fig:deps-set-algo1}
}	
\hspace*{0.1in}\subfigure[receive of \texttt{cmd} and \texttt{deps} messages, and suggestion of dependencies for a command on process $p$.]{
\noindent\fbox{%
	\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}
	
		\begin{algorithmic}[1]
			\makeatletter
			\setcounter{ALG@line}{8}
			\makeatother
			{\scriptsize
			\START[$\langle \texttt{cmd}$ $|$ $c \rangle$]{{\bf upon receive}}{ {\bf from} $q$} \label{alg:receive-new-cmd}
			\State $\mathcal{D} \gets \{ d : d \in cmds_p \land$\label{alg:update-d}
			\Statex \hspace{2cm}$\land d\neq c \land d \asymp c \}$
			\State $cmds_p\gets cmds_p\cup\{c\}$\label{alg:update-cmds-p}
			\State {\bf send} $\langle \texttt{deps}$ $|$ $c,\mathcal{D} \rangle$ {\bf to} $q$\label{alg:send-deps}
			\END
			\Statex
			\START[$\langle \texttt{deps}$ $|$ $c,\mathcal{D} \rangle$]{{\bf upon receive}}{ {\bf from} $q$} \label{alg:receive-deps}
			\State $deps_p[c]\gets deps_p[c]\cup \mathcal{D}$\label{alg:update-deps-p}
			\State $heard_p[c]\gets heard_p[c]\cup \{q\}$
			\END
			\Statex
			\START[]{{\bf upon}}{$\exists c$ $:$ $ | heard_p[c] | \geq \mathcal{Q}$ $\land$} \label{alg:receive-deps}
			\Statex \hspace{1cm}$\land$ $suggested_p[c]=false$
			\State $suggested_p[c]\gets true$
			\State {\bf call} $\texttt{suggest}_p(c,deps_p[c])$ \label{alg:call-suggest}
			\END
			}
		\end{algorithmic}
	\end{varwidth}%
}
\label{fig:deps-set-algo2}
}
\hspace*{0.1in}\subfigure[Leaderless generalized consensus implementation.]{
\noindent\fbox{%
	\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}
 
    
		\begin{algorithmic}[1]
			{\scriptsize
			\START[$\opn{init}_p$]{{\bf upon}}{$()$}
			\State $m_p\gets \emptyset$
			\State $\sigma_p\gets \bot$
			\END
			\START[$\opn{GC-propose}_p$]{{\bf upon}}{$(c)$}
			\State {\bf call} $\opn{announce}_p\left( c \right)$
			\END
			\Statex
			\START[$\opn{suggest}_p$]{{\bf upon}}{$(c,\mathcal{D})$}
			\State  $\opn{propose}_p( c,\mathcal{D})$ 			
			\END
			\Statex
			\START[$\opn{commit}_p$]{{\bf upon}}{$(c,\mathcal{D})$}
			\State  $m_p \gets m_p \oplus \left[ c \mapsto \mathcal{D}\right]$	
			\State $\sigma_p \gets  \opn{c-struct}\left(m_p\right)$
			\State $\opn{GC-decide}_p(\sigma_p)$		
			\END
			}
		\end{algorithmic}
	\end{varwidth}%
}
\label{fig:deps-set-algo3}
}
\caption{Example of dependency-set algorithm and leaderless generalized consensus implementations.}
\label{fig:deps-set-algo}
\end{figure*}

%\todo{Plain english version below. Which is better?}

%A dependency-set computation algorithm allows processes to announce a command $c$ and to learn about a suggested dependency set for a previously announced command.
%Moreover, a dependency-set computation algorithm must ensure that:
%\begin{enumerate}[noitemsep,nolistsep]
  %  \item If the dependency set $d$ has been suggested for $c$, then every command in $\aset{c}\cup d$ must have been announced before.
  %  \item If the dependency set $d_1$ has been suggested for the command $c_1$, the dependency set $d_2$ has been suggested for the command $c_2$, and $c_1$ and $c_2$ do not commute, then either $c_1\in d_2$ or $c_2 \in d_1$.
%\end{enumerate}

Any implementation of dependency-set algorithm can rely on the garbage collection of the map-agreement module to get rid of redundant information associated with specific commands in its data structures, with the purpose of preventing the dependency sets to grow indefinitely. 
 
\todo{``Suggest'' can also be used to trigger recovery. Describe better this part.}
%\todo{Write a suggestion on about GC of dependencies. Remove any command c such that a committed command depends on c. Also us the GC of the map-agreement component.}

\subsection{Agreeing on Dependency Sets}
\label{map-algo}

A map-agreement algorithm exposes the input interface $\opn{propose}_p\left( c, \mathcal{D} \right)$, to propose a set of dependencies $\mathcal{D}$ for a command $c$, and the output interface $\opn{commit}_p\left( c, \mathcal{D} \right)$, to commit $\mathcal{D}$ for $c$, where $p\in P$ is the process executing the call.
Moreover, a map-agreement algorithm must ensure that: 
\begin{comment}
\begin{enumerate}[noitemsep,nolistsep]
    \item If the set of dependencies $\mathcal{D}$ is committed for a command $c$, then $\mathcal{D}$ has been proposed for $c$ at an earlier time.
    \item If $\mathcal{D}_1$ is committed for a command $c$ and $\mathcal{D}_2$ is committed for the same command $c$, then $\mathcal{D}_1$ is equal to $\mathcal{D}_2$.
 \end{enumerate}

\todo{OR MORE FORMALLY}

\end{comment}

\begin{enumerate}[noitemsep,nolistsep]
    \item For any decision $\opn{commit}_p\left( c, \mathcal{D} \right)$, then $\mathcal{D}$ has been proposed for $c$ at an earlier time.
    \item For any two decisions $\opn{commit}_p\left( c, \mathcal{D}_1 \right)$, $\opn{commit}_q\left( c, \mathcal{D}_2 \right)$ (with $p$ possibly equal to $q$), then $\mathcal{D}_1$ is equal to $\mathcal{D}_2$.


\end{enumerate}

An example of implementation of the map-agreement algorithm can be any state machine replication algorithm, like MultiPaxos~\cite{lamport2001paxos}, where a pair of command $c$ and dependency-set $\mathcal{D}$ can be proposed to a instance of MultiPaxos that is identified by the command $c$ itself.
%used to implementing map-agreement by uniquely associating commands to MultiPaxos instance numbers.




\todo{Cite Generalized Paxos as an example for bounding the data structures. Problem: we do not describe any particular data structure here. It is not clear why we should write about GC here.}

\subsection{Processing the Dependency Graph}
\label{abstract-algo}

\begin{comment}
Local variables: $m_p$, a map from commands to dependency sets, initially the empty map; $\sigma_p$, a c-struct, initially $\bot$.
\begin{itemize}[noitemsep,nolistsep]
    \item Upon ${\opn{propose}\left( c \right)}^p$: call ${\opn{announce}\left( c \right)}^p$.
    \item Upon ${\opn{suggest}\left( c,d \right)}^p$: call ${\opn{propose}\left( c,d \right)}^p$.
    \item Upon ${\opn{decide}\left( c,d \right)}^p$: insert the mapping $c \rightarrow d$ in the map $m_p$.
    \item Periodically, update $\sigma_p$ to $\opn{c-struct}\left( m_p \right)$, where $\opn{c-struct}\left( m_p \right)$ is defined below.
\end{itemize}

\end{comment}

The graph processing algorithm is executed locally by a node (line 10 of \cref{fig:deps-set-algo3}). It must compute the value of $\opn{c-struct}\left( g_p \right)$, as defined in \cref{lindef}.
Its key property is \cref{lemma1}. 
We assume that processes initially agree, for each set of commands $\mathcal{D}$, on a total order $<_{\mathcal{D}}$ on $\mathcal{D}$.
In practice, if commands are attached a unique identifier among a totally ordered set, $<_{\mathcal{D}}$ can be the restriction of this total order on $\mathcal{D}$.

%\textbf{Local dependency graph computed by a process.} 
We say that a command $c$ in the domain of $m_p$ is \emph{executable} when no command $c$ which is not in the domain of $m_p$ can be reached from $c$ by recursively following $c$'s dependencies.
The local variable $m_p$ denotes a directed graph $g_p$ whose set of vertices $V\left( g_p \right)$ is the executable commands of $m_p$ and whose edges $E\left( g_p \right)$ are such that there is an edge from $c_1$ to $c_2$ iff $c_2 \in m_p\left[ c_1 \right]$ (i.e., $c_1$ depends on $c_2$). For example, if $m_p = \left[ c_1 \mapsto \aset{c_2,c_4}, c_2 \mapsto \aset{c_3}, c_3 \mapsto \aset{c_2}\right]$ then $V\left( g_p \right) = \aset{c_2,c_3}$ and $E\left( g_p \right) = \aset{\left( c_2,c_3 \right),\left( c_3,c_2 \right)}$.

%\textbf{Orders induced by a graph.}
A directed graph $g$ \emph{induces a partial order} $\preceq_g$ on its vertices defined such that $c_1 \preceq_g c_2$ iff there is a path from $c_1$ to $c_2$ and none from $c_2$ to $c_1$.
%Let $\opn{TOs}\left( g \right)$ be the set of total orders $o$ such that $\preceq_g \subseteq o$.
For example, consider $h$ where $V\left( h \right)=\aset{c_1,c_2,c_3,c_4}$ and $E\left( h \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right),\left( c_1,c_3 \right)}$. 
We have that $\preceq_h = \aset{\left( c_1,c_3 \right)}$.
%If $c\in V\left( g \right)$, we write $\left[ c \right]_g$ for the strongly connected component of $g$ to which $c$ belongs. 
%\textbf{Linearizations of a dependency graph.}
We say that a total order $\ll$ on $V\left( g \right)$ is a \emph{linearization} of $g$ when for every $c_1,c_2\in V\left( g \right)$, $c_1 \preceq_g c_2$ implies $c_1 \ll c_2$, and if $c_1$ and $c_2$ belong to the same strongly connected component $\mathcal{D}$ and $ c_1 <_{\mathcal{D}} c_2$ hold, then $c_1 \ll c_2$. For example, assuming that $c_2 \leq_{\aset{c_1,c_2}} c_1$, the linearizations of $h$ are $\aseq{c_2,c_1,c_3,c_4}$, $\aseq{c_2,c_1,c_4,c_3}$, $\aseq{c_2,c_4,c_1,c_3}$, and $\aseq{c_4,c_2,c_1,c_3}$.
%\textbf{Partial order on graphs.}

\begin{comment}
We now define a partial order on graphs. If $g_1$ and $g_2$ are two graphs, then we write $g_1 \leq g_2$ iff $V\left( g_1 \right)\subseteq V\left( g_2 \right)$, and if $v\in V\left( g_1 \right)$, $e\in E\left( g_2 \right)$, and $v$ is an endpoint of $e$, then $e\in E\left( g_1 \right)$. 
For example, consider the graphs $h'$ and $h''$ such that $V\left( h' \right)=\aset{c_1,c_2,c_4}$, $E\left( h' \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right)}$, $V\left( h'' \right)=\aset{c_1,c_3,c_4}$, and $E\left( h'' \right)=\aset{\left( c_1,c_3 \right)}$. We have that $h'\leq h$, but $ h''\not\leq h$.
\end{comment}

Define the intersection of two graphs such that $V\left( g_1 \cap g_2 \right)=V\left( g_1 \right)\cap V\left( g_2 \right)$ and $E\left( g_1 \cap g_2 \right)= E\left( g_1 \right)\cap E\left( g_2 \right)$, and define their union such that $V\left( g_1 \cup g_2 \right)=V\left( g_1 \right)\cup V\left( g_2 \right)$ and $E\left( g_1 \cup g_2 \right)= E\left( g_1 \right)\cup E\left( g_2 \right)$.
Define two graphs $g_1$ and $g_2$ as being \emph{compatible} iff $g_1 \cap g_2$ is a vertex-induced subgraph of $g_1 \cup g_2$.

\begin{mylemma}\label{lemma1}
Assume that $g_1$ and $g_2$ are two dependency graphs, 
that for every pair of non-commutative commands $c_1,c_2 \in V\left(g_2\right)$, either $\left( c_1,c_2 \right)\in E\left( g_2 \right)$ or $\left( c_2,c_1 \right)\in E\left( g_2 \right)$,
that $g_1$ and $g_2$ are compatible,
that $l_1$ is a linearization of $g_1$, and that $l_2$ is a linearization of $g_2$. 
Then we have (a), $\bot\bullet l_1$ and $\bot\bullet l_2$ are compatible c-structs, and (b), if $g_1 = g_2$ then $\bot\bullet l_1 = \bot\bullet l_2$.
\end{mylemma}

\begin{mydef}\label{lindef}
We define $\opn{c-struct}\left( m_p \right) = \bot\bullet l$ where $l$ is a linearization of $g_p$.
By lemma 1.b, $\opn{c-struct}\left( m_p \right)$ is well-defined.
\end{mydef}


\begin{comment}

\textbf{Graph of strongly connected components.} Given a graph $g$, let $\hat{g}$ be the graph whose vertices are the strongly connected components of $g$ (represented as sets of vertices) and where there is an edge from $g_1$ to $g_2$ if and only if there are two vertices $v_1$ and $v_2$ of $g$ such that $v_1 \in V\left( g_1 \right)$, $v_2 \in V\left( g_2 \right)$, and $\left( v_1,v_2 \right)\in E\left( g \right)$. Note that the reflexive and transitive closure of $V\left(  \hat{g} \right)$ is necessarily a partial order. 
For example, consider $h$ such that $V\left( h \right)=\aset{c_1,c_2,c_3,c_4}$ and $E\left( h \right)=\aset{\left( c_1,c_2 \right),\left( c_2,c_1 \right),\left( c_1,c_3 \right)}$. Then $V(\hat{h}) = \aset{\aset{c_1,c_2},\aset{c_3},\aset{c_4}}$ and $E( \hat{h} )=\aset{\left( \aset{c_1,c_2},\aset{c_3} \right)}$. We will use $h$ as an example in the rest of the section.

\textbf{Linearization function.} Consider a function $f$ mapping sets of commands to sequences of commands such that $f\left[ \mathcal{D} \right]$ is a total order on the set $\mathcal{D}$.

\textbf{Linearizations of a dependency graph.}
When $\hat{o}$ is a total order over the strongly connected components of $g$ such that $\hat{o} \in \opn{TOs}\left( \hat{g} \right)$, we say that a total order $l$ on $V\left( g \right)$ is a \emph{linearization} of $g$ when $\left(v_1,v_2\right) \in l$ iff (1) there exists $vs_1,vs_2\in V\left(\hat{g}\right)$ such that $v_1\in vs_1$, $v_2\in vs_2$, and $\left( vs_1,vs_2 \right)\in \hat{o}$, or (2) there exists $vs_1\in V\left(\hat{g}\right)$ such that
$v_1,v_2\in  vs_1$ and $\left( v_1,v_2 \right)\in f\left[  vs_1 \right]$.
For example, if $f\left[ \aset{c_1,c_2} \right] = \aseq{c_2,c_1}$ then $\aseq{c_2,c_1,c_3,c_4}$ is a linearization of $h$ but $\aseq{c_1,c_2,c_3,c_4}$ is not and neither is $\aseq{c_3,c_2,c_1,c_4}$

\end{comment}

\begin{comment}
Define $\opn{Lin}_g\left( \leq \right) = f\left[ V_1 \right] \cdot F\left[ V_2 \right] \cdot F\left[ V_n \right]$, where $V_i\in V\left( \hat{g} \right)$ 


Define the set of linearizations $\opn{Lins}\left( g \right)$ of a graph $g$ as the set of sequences whose length is the cardinality of $V\left( g \right)$, which contain each element of $V\left( g \right)$ exactly once, and ... \todo{or first define the partial order induced by a graph and then its compatible total orders.}

Consider a function $f$ mapping sets of commands to sequences of commands such that $f\left[ \mathcal{D} \right]$ contains each command in $\mathcal{D}$ exactly once.
A sequence of commands $cseq$ is an $f$-linearization of the graph $g$ if and only there is a sequence whose element of strongly connected 

\todo{Explain the graph processing algo independently? Its key property is that when $G1 \subseteq G2$ then $lin\left( c_1,G1 \right)$ is a prefix of $lin\left( c_2,G2 \right)$ or vice-versa.}

\end{comment}

\subsection{Consistency and Liveness}

\textbf{Lemma 2}
If $g_p^1$ is the graph $g_p$ at time $t_1$, $g_q^2$ is the graph $g_q$ at time $t_2$, then $g_p^1$ and $g_q^2$ are compatible.

\begin{comment}
\textbf{Lemma 3}
Consider $g_1$ and $g_2$. Assume that if $v\in V\left( g_1 \right)$ and $v\in V\left( g_2 \right)$ then $n\left( g_1 \right)=n\left( g2 \right)$.

\textbf{Lemma 4}
If $m_p\subseteq m_q$

\end{comment}

\subsection{Obtaining EPaxos}

\printbibliography%

\appendix

\section{Generalized Consensus}

A c-struct set is a set containing the element $\bot$ and with an append operator $\bullet$ such that $\sigma \bullet c$ is a c-struct, for any c-struct $\sigma$ and command $c$. 
We also write the $\sigma\bullet\aseq{c_1,\cdots,c_n}$ for the c-struct $\sigma\bullet c_1\bullet\cdots\bullet c_n$.
C-structs are partially ordered by the relation $\sqsubseteq$ defined such that $\sigma_1\sqsubseteq\sigma_2$ iff there exists a sequence of commands $\mathcal{D}$ such that $\sigma_2=\sigma_1\bullet \mathcal{D}$. Two c-structs are compatible when they have a common upper bound; when this is the case, two c-structs $\sigma_1$ and $\sigma_2$ have a least upper bound, noted $\bigsqcup\left( \sigma_1,\sigma_2 \right)$.
We say that two commands \textit{commute} when $\sigma\bullet c_1\bullet c_2 =  \sigma\bullet c_2\bullet c_1 $, for every c-struct $\sigma$. Intuitively, a c-struct represents a set of sequences that are all equivalent up to the ordering of commutative commands (see~\cite{Lamport05GeneralizeConsensus} for a complete discussion on c-struct). 
In the rest of the paper the symbol $c$, possibly sub-scripted, ranges over commands, and the symbol $\mathcal{D}$, possibly sub-scripted, ranges over sets of commands.

We can now state the generalized-consensus properties: non-triviality requires that any decided c-struct be of the form $\bot\bullet \mathcal{D}$, where $\mathcal{D}$ is a sequence of proposed commands; consistency requires than any two decided c-structs $\sigma_1$ and $\sigma_2$ be compatible; stability requires that when a process $p$ decides a c-struct $\sigma_1$ and time $t_1$ and $\sigma_2$ at time $t_2$, then $t_1 \leq t_2$ implies that $\sigma_1\sqsubseteq \sigma_2$; finally, liveness requires that
if a command keeps beeing proposed, then a c-struct $\sigma$ containing the command is eventually decided.

\end{document}
